#!/bin/bash

BEHIND_ICON="⇃"
AHEAD_ICON="↾"

# Parse git status in $1 used in prompt
git_prompt () {

  git status &> /dev/null
  if [[ $? -ne 0 ]]; then
    echo "\[\e[0;38;5;23m\]\[\e[0m\]"
    return
  fi

  readarray -t st < <(git -C $1 status --porcelain=v2 -b | grep -e '^#')
  changes=""
  branch=""
  ahead=0
  behind=0

  if ! git diff-index --quiet HEAD --; then
    changes="⚡"
  fi

  for l in "${st[@]}"; do
    case "$(cut -d ' ' -f2 <<< $l)" in
      branch.head)
        branch=$(cut -d ' ' -f3 <<< $l)
        ;;
      branch.upstream)
        branch=$(cut -d ' ' -f3 <<< $l)
        ;;
      branch.ab)
        ahead=$(echo $l | cut -d ' ' -f3 | sed 's/\+//')
        behind=$(echo $l | cut -d ' ' -f4 | sed 's/-//')
        ;;
    esac
  done

  # \[\e[0;38;5;23;43m\]\[\e[0;1;38;5;235;43m\]  branch change \[\e[0;33;41m\]\[\e[0;41m\] behind ahead \[\e[0;31m\]\[\e[0m\]

  if (($ahead+$behind > 0)); then
    echo "\[\e[0;38;5;23;43m\]\[\e[0;1;38;5;235;43m\]  $branch $changes \[\e[0;33;41m\]\[\e[0;1;31;48;5;130m\]$behind $BEHIND_ICON\[\e[0;1;38;5;28;48;5;130m\]$AHEAD_ICON $ahead\[\e[0;31m\]\[\e[0m\]"
  else
    echo "\[\e[0;38;5;23;43m\]\[\e[0;1;38;5;235;43m\]  $branch $changes \[\e[0;33m\]\[\e[0m\]"
  fi
}
export -f git_prompt
